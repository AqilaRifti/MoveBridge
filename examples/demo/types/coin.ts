/**
 * Auto-generated TypeScript bindings for 0x1::coin
 * Generated by @movebridge/codegen
 */

import type { Movement } from '@movebridge/core';

export class CoinContract {
  private readonly movement: Movement;
  private readonly address = '0x1';
  private readonly module = 'coin';

  /**
   * Creates a new CoinContract instance
   * @param movement - Movement SDK instance
   */
  constructor(movement: Movement) {
    this.movement = movement;
  }

  /**
   * Entry function: extract
   * @param arg0 - Parameter of type &mut 0x1::coin::Coin<T0>
   * @param arg1 - Parameter of type u64
   * @param typeArgs - Type arguments
   * @returns Transaction hash
   */
  async extract<T0 = unknown>(arg0: unknown, arg1: string, typeArgs: string[]): Promise<string> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.call('extract', [arg0, arg1], typeArgs);
  }

  /**
   * Entry function: value
   * @param arg0 - Parameter of type &0x1::coin::Coin<T0>
   * @param typeArgs - Type arguments
   * @returns Transaction hash
   */
  async value<T0 = unknown>(arg0: unknown, typeArgs: string[]): Promise<string> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.call('value', [arg0], typeArgs);
  }

  /**
   * Entry function: merge
   * @param arg0 - Parameter of type &mut 0x1::coin::Coin<T0>
   * @param arg1 - Parameter of type 0x1::coin::Coin<T0>
   * @param typeArgs - Type arguments
   * @returns Transaction hash
   */
  async merge<T0 = unknown>(arg0: unknown, arg1: unknown, typeArgs: string[]): Promise<string> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.call('merge', [arg0, arg1], typeArgs);
  }

  /**
   * Entry function: initialize
   * @param arg0 - Parameter of type 0x1::string::String
   * @param arg1 - Parameter of type 0x1::string::String
   * @param arg2 - Parameter of type u8
   * @param arg3 - Parameter of type bool
   * @param typeArgs - Type arguments
   * @returns Transaction hash
   */
  async initialize<T0 = unknown>(arg0: string, arg1: string, arg2: number, arg3: boolean, typeArgs: string[]): Promise<string> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.call('initialize', [arg0, arg1, arg2, arg3], typeArgs);
  }

  /**
   * Entry function: burn
   * @param arg0 - Parameter of type 0x1::coin::Coin<T0>
   * @param arg1 - Parameter of type &0x1::coin::BurnCapability<T0>
   * @param typeArgs - Type arguments
   * @returns Transaction hash
   */
  async burn<T0 = unknown>(arg0: unknown, arg1: unknown, typeArgs: string[]): Promise<string> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.call('burn', [arg0, arg1], typeArgs);
  }

  /**
   * Entry function: transfer
   * @param arg0 - Parameter of type address
   * @param arg1 - Parameter of type u64
   * @param typeArgs - Type arguments
   * @returns Transaction hash
   */
  async transfer<T0 = unknown>(arg0: string, arg1: string, typeArgs: string[]): Promise<string> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.call('transfer', [arg0, arg1], typeArgs);
  }

  /**
   * View function: name
   * @param typeArgs - Type arguments
   * @returns Function result
   */
  async name<T0 = unknown>(, typeArgs: string[]): Promise<string> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.view<string>('name', [], typeArgs);
  }

  /**
   * View function: symbol
   * @param typeArgs - Type arguments
   * @returns Function result
   */
  async symbol<T0 = unknown>(, typeArgs: string[]): Promise<string> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.view<string>('symbol', [], typeArgs);
  }

  /**
   * View function: decimals
   * @param typeArgs - Type arguments
   * @returns Function result
   */
  async decimals<T0 = unknown>(, typeArgs: string[]): Promise<number> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.view<number>('decimals', [], typeArgs);
  }

  /**
   * View function: balance
   * @param arg0 - Parameter of type address
   * @param typeArgs - Type arguments
   * @returns Function result
   */
  async balance<T0 = unknown>(arg0: string, typeArgs: string[]): Promise<string> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.view<string>('balance', [arg0], typeArgs);
  }

  /**
   * Entry function: burn_from
   * @param arg0 - Parameter of type address
   * @param arg1 - Parameter of type u64
   * @param arg2 - Parameter of type &0x1::coin::BurnCapability<T0>
   * @param typeArgs - Type arguments
   * @returns Transaction hash
   */
  async burnFrom<T0 = unknown>(arg0: string, arg1: string, arg2: unknown, typeArgs: string[]): Promise<string> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.call('burn_from', [arg0, arg1, arg2], typeArgs);
  }

  /**
   * Entry function: deposit
   * @param arg0 - Parameter of type address
   * @param arg1 - Parameter of type 0x1::coin::Coin<T0>
   * @param typeArgs - Type arguments
   * @returns Transaction hash
   */
  async deposit<T0 = unknown>(arg0: string, arg1: unknown, typeArgs: string[]): Promise<string> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.call('deposit', [arg0, arg1], typeArgs);
  }

  /**
   * Entry function: destroy_zero
   * @param arg0 - Parameter of type 0x1::coin::Coin<T0>
   * @param typeArgs - Type arguments
   * @returns Transaction hash
   */
  async destroyZero<T0 = unknown>(arg0: unknown, typeArgs: string[]): Promise<string> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.call('destroy_zero', [arg0], typeArgs);
  }

  /**
   * View function: is_balance_at_least
   * @param arg0 - Parameter of type address
   * @param arg1 - Parameter of type u64
   * @param typeArgs - Type arguments
   * @returns Function result
   */
  async isBalanceAtLeast<T0 = unknown>(arg0: string, arg1: string, typeArgs: string[]): Promise<boolean> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.view<boolean>('is_balance_at_least', [arg0, arg1], typeArgs);
  }

  /**
   * Entry function: mint
   * @param arg0 - Parameter of type u64
   * @param arg1 - Parameter of type &0x1::coin::MintCapability<T0>
   * @param typeArgs - Type arguments
   * @returns Transaction hash
   */
  async mint<T0 = unknown>(arg0: string, arg1: unknown, typeArgs: string[]): Promise<string> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.call('mint', [arg0, arg1], typeArgs);
  }

  /**
   * View function: supply
   * @param typeArgs - Type arguments
   * @returns Function result
   */
  async supply<T0 = unknown>(, typeArgs: string[]): Promise<unknown> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.view<unknown>('supply', [], typeArgs);
  }

  /**
   * Entry function: withdraw
   * @param arg0 - Parameter of type u64
   * @param typeArgs - Type arguments
   * @returns Transaction hash
   */
  async withdraw<T0 = unknown>(arg0: string, typeArgs: string[]): Promise<string> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.call('withdraw', [arg0], typeArgs);
  }

  /**
   * Entry function: zero
   * @param typeArgs - Type arguments
   * @returns Transaction hash
   */
  async zero<T0 = unknown>(, typeArgs: string[]): Promise<string> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.call('zero', [], typeArgs);
  }

  /**
   * Entry function: deposit_with_signer
   * @param arg0 - Parameter of type 0x1::coin::Coin<T0>
   * @param typeArgs - Type arguments
   * @returns Transaction hash
   */
  async depositWithSigner<T0 = unknown>(arg0: unknown, typeArgs: string[]): Promise<string> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.call('deposit_with_signer', [arg0], typeArgs);
  }

  /**
   * Entry function: allow_supply_upgrades
   * @param arg0 - Parameter of type bool
   * @returns Transaction hash
   */
  async allowSupplyUpgrades(arg0: boolean): Promise<string> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.call('allow_supply_upgrades', [arg0], []);
  }

  /**
   * Entry function: burn_from_for_gas
   * @param arg0 - Parameter of type address
   * @param arg1 - Parameter of type u64
   * @param arg2 - Parameter of type &0x1::coin::BurnCapability<T0>
   * @param typeArgs - Type arguments
   * @returns Transaction hash
   */
  async burnFromForGas<T0 = unknown>(arg0: string, arg1: string, arg2: unknown, typeArgs: string[]): Promise<string> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.call('burn_from_for_gas', [arg0, arg1, arg2], typeArgs);
  }

  /**
   * View function: coin_supply
   * @param typeArgs - Type arguments
   * @returns Function result
   */
  async coinSupply<T0 = unknown>(, typeArgs: string[]): Promise<unknown> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.view<unknown>('coin_supply', [], typeArgs);
  }

  /**
   * Entry function: coin_to_fungible_asset
   * @param arg0 - Parameter of type 0x1::coin::Coin<T0>
   * @param typeArgs - Type arguments
   * @returns Transaction hash
   */
  async coinToFungibleAsset<T0 = unknown>(arg0: unknown, typeArgs: string[]): Promise<string> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.call('coin_to_fungible_asset', [arg0], typeArgs);
  }

  /**
   * Entry function: convert_and_take_paired_burn_ref
   * @param arg0 - Parameter of type 0x1::coin::BurnCapability<T0>
   * @param typeArgs - Type arguments
   * @returns Transaction hash
   */
  async convertAndTakePairedBurnRef<T0 = unknown>(arg0: unknown, typeArgs: string[]): Promise<string> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.call('convert_and_take_paired_burn_ref', [arg0], typeArgs);
  }

  /**
   * Entry function: deposit_for_gas_fee
   * @param arg0 - Parameter of type address
   * @param arg1 - Parameter of type 0x1::coin::Coin<T0>
   * @param typeArgs - Type arguments
   * @returns Transaction hash
   */
  async depositForGasFee<T0 = unknown>(arg0: string, arg1: unknown, typeArgs: string[]): Promise<string> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.call('deposit_for_gas_fee', [arg0, arg1], typeArgs);
  }

  /**
   * Entry function: destroy_burn_cap
   * @param arg0 - Parameter of type 0x1::coin::BurnCapability<T0>
   * @param typeArgs - Type arguments
   * @returns Transaction hash
   */
  async destroyBurnCap<T0 = unknown>(arg0: unknown, typeArgs: string[]): Promise<string> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.call('destroy_burn_cap', [arg0], typeArgs);
  }

  /**
   * Entry function: destroy_freeze_cap
   * @param arg0 - Parameter of type 0x1::coin::FreezeCapability<T0>
   * @param typeArgs - Type arguments
   * @returns Transaction hash
   */
  async destroyFreezeCap<T0 = unknown>(arg0: unknown, typeArgs: string[]): Promise<string> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.call('destroy_freeze_cap', [arg0], typeArgs);
  }

  /**
   * Entry function: destroy_mint_cap
   * @param arg0 - Parameter of type 0x1::coin::MintCapability<T0>
   * @param typeArgs - Type arguments
   * @returns Transaction hash
   */
  async destroyMintCap<T0 = unknown>(arg0: unknown, typeArgs: string[]): Promise<string> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.call('destroy_mint_cap', [arg0], typeArgs);
  }

  /**
   * Entry function: ensure_paired_metadata
   * @param typeArgs - Type arguments
   * @returns Transaction hash
   */
  async ensurePairedMetadata<T0 = unknown>(, typeArgs: string[]): Promise<string> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.call('ensure_paired_metadata', [], typeArgs);
  }

  /**
   * Entry function: extract_all
   * @param arg0 - Parameter of type &mut 0x1::coin::Coin<T0>
   * @param typeArgs - Type arguments
   * @returns Transaction hash
   */
  async extractAll<T0 = unknown>(arg0: unknown, typeArgs: string[]): Promise<string> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.call('extract_all', [arg0], typeArgs);
  }

  /**
   * Entry function: freeze_coin_store
   * @param arg0 - Parameter of type address
   * @param arg1 - Parameter of type &0x1::coin::FreezeCapability<T0>
   * @param typeArgs - Type arguments
   * @returns Transaction hash
   */
  async freezeCoinStore<T0 = unknown>(arg0: string, arg1: unknown, typeArgs: string[]): Promise<string> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.call('freeze_coin_store', [arg0, arg1], typeArgs);
  }

  /**
   * Entry function: get_paired_burn_ref
   * @param arg0 - Parameter of type &0x1::coin::BurnCapability<T0>
   * @param typeArgs - Type arguments
   * @returns Transaction hash
   */
  async getPairedBurnRef<T0 = unknown>(arg0: unknown, typeArgs: string[]): Promise<string> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.call('get_paired_burn_ref', [arg0], typeArgs);
  }

  /**
   * Entry function: get_paired_mint_ref
   * @param arg0 - Parameter of type &0x1::coin::MintCapability<T0>
   * @param typeArgs - Type arguments
   * @returns Transaction hash
   */
  async getPairedMintRef<T0 = unknown>(arg0: unknown, typeArgs: string[]): Promise<string> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.call('get_paired_mint_ref', [arg0], typeArgs);
  }

  /**
   * Entry function: get_paired_transfer_ref
   * @param arg0 - Parameter of type &0x1::coin::FreezeCapability<T0>
   * @param typeArgs - Type arguments
   * @returns Transaction hash
   */
  async getPairedTransferRef<T0 = unknown>(arg0: unknown, typeArgs: string[]): Promise<string> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.call('get_paired_transfer_ref', [arg0], typeArgs);
  }

  /**
   * Entry function: initialize_with_parallelizable_supply
   * @param arg0 - Parameter of type 0x1::string::String
   * @param arg1 - Parameter of type 0x1::string::String
   * @param arg2 - Parameter of type u8
   * @param arg3 - Parameter of type bool
   * @param typeArgs - Type arguments
   * @returns Transaction hash
   */
  async initializeWithParallelizableSupply<T0 = unknown>(arg0: string, arg1: string, arg2: number, arg3: boolean, typeArgs: string[]): Promise<string> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.call('initialize_with_parallelizable_supply', [arg0, arg1, arg2, arg3], typeArgs);
  }

  /**
   * View function: is_account_registered
   * @param arg0 - Parameter of type address
   * @param typeArgs - Type arguments
   * @returns Function result
   */
  async isAccountRegistered<T0 = unknown>(arg0: string, typeArgs: string[]): Promise<boolean> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.view<boolean>('is_account_registered', [arg0], typeArgs);
  }

  /**
   * View function: is_coin_initialized
   * @param typeArgs - Type arguments
   * @returns Function result
   */
  async isCoinInitialized<T0 = unknown>(, typeArgs: string[]): Promise<boolean> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.view<boolean>('is_coin_initialized', [], typeArgs);
  }

  /**
   * View function: is_coin_store_frozen
   * @param arg0 - Parameter of type address
   * @param typeArgs - Type arguments
   * @returns Function result
   */
  async isCoinStoreFrozen<T0 = unknown>(arg0: string, typeArgs: string[]): Promise<boolean> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.view<boolean>('is_coin_store_frozen', [arg0], typeArgs);
  }

  /**
   * Entry function: migrate_coin_store_to_fungible_store
   * @param arg0 - Parameter of type vector<address>
   * @param typeArgs - Type arguments
   * @returns Transaction hash
   */
  async migrateCoinStoreToFungibleStore<T0 = unknown>(arg0: string[], typeArgs: string[]): Promise<string> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.call('migrate_coin_store_to_fungible_store', [arg0], typeArgs);
  }

  /**
   * View function: paired_burn_ref_exists
   * @param typeArgs - Type arguments
   * @returns Function result
   */
  async pairedBurnRefExists<T0 = unknown>(, typeArgs: string[]): Promise<boolean> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.view<boolean>('paired_burn_ref_exists', [], typeArgs);
  }

  /**
   * View function: paired_coin
   * @param arg0 - Parameter of type 0x1::object::Object<0x1::fungible_asset::Metadata>
   * @returns Function result
   */
  async pairedCoin(arg0: unknown): Promise<unknown> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.view<unknown>('paired_coin', [arg0], []);
  }

  /**
   * View function: paired_metadata
   * @param typeArgs - Type arguments
   * @returns Function result
   */
  async pairedMetadata<T0 = unknown>(, typeArgs: string[]): Promise<unknown> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.view<unknown>('paired_metadata', [], typeArgs);
  }

  /**
   * View function: paired_mint_ref_exists
   * @param typeArgs - Type arguments
   * @returns Function result
   */
  async pairedMintRefExists<T0 = unknown>(, typeArgs: string[]): Promise<boolean> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.view<boolean>('paired_mint_ref_exists', [], typeArgs);
  }

  /**
   * View function: paired_transfer_ref_exists
   * @param typeArgs - Type arguments
   * @returns Function result
   */
  async pairedTransferRefExists<T0 = unknown>(, typeArgs: string[]): Promise<boolean> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.view<boolean>('paired_transfer_ref_exists', [], typeArgs);
  }

  /**
   * Entry function: return_paired_burn_ref
   * @param arg0 - Parameter of type 0x1::fungible_asset::BurnRef
   * @param arg1 - Parameter of type 0x1::coin::BurnRefReceipt
   * @returns Transaction hash
   */
  async returnPairedBurnRef(arg0: unknown, arg1: unknown): Promise<string> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.call('return_paired_burn_ref', [arg0, arg1], []);
  }

  /**
   * Entry function: return_paired_mint_ref
   * @param arg0 - Parameter of type 0x1::fungible_asset::MintRef
   * @param arg1 - Parameter of type 0x1::coin::MintRefReceipt
   * @returns Transaction hash
   */
  async returnPairedMintRef(arg0: unknown, arg1: unknown): Promise<string> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.call('return_paired_mint_ref', [arg0, arg1], []);
  }

  /**
   * Entry function: return_paired_transfer_ref
   * @param arg0 - Parameter of type 0x1::fungible_asset::TransferRef
   * @param arg1 - Parameter of type 0x1::coin::TransferRefReceipt
   * @returns Transaction hash
   */
  async returnPairedTransferRef(arg0: unknown, arg1: unknown): Promise<string> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.call('return_paired_transfer_ref', [arg0, arg1], []);
  }

  /**
   * Entry function: unfreeze_coin_store
   * @param arg0 - Parameter of type address
   * @param arg1 - Parameter of type &0x1::coin::FreezeCapability<T0>
   * @param typeArgs - Type arguments
   * @returns Transaction hash
   */
  async unfreezeCoinStore<T0 = unknown>(arg0: string, arg1: unknown, typeArgs: string[]): Promise<string> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.call('unfreeze_coin_store', [arg0, arg1], typeArgs);
  }

  /**
   * Entry function: withdraw_from
   * @param arg0 - Parameter of type address
   * @param arg1 - Parameter of type u64
   * @param typeArgs - Type arguments
   * @returns Transaction hash
   */
  async withdrawFrom<T0 = unknown>(arg0: string, arg1: string, typeArgs: string[]): Promise<string> {
    const contract = this.movement.contract({
      address: this.address,
      module: this.module,
    });
    return contract.call('withdraw_from', [arg0, arg1], typeArgs);
  }

}