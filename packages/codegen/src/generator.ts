/**
 * @movebridge/codegen - Type Generator
 * Generates TypeScript code from Move module ABIs
 */

import { ABIParser, type ModuleABI, type FunctionABI } from './parser';

/**
 * Type Generator
 * Generates TypeScript classes from Move module ABIs
 */
export class TypeGenerator {
    private parser: ABIParser;

    constructor(parser: ABIParser) {
        this.parser = parser;
    }

    /**
     * Generates a TypeScript class from a module ABI
     * @param abi - Module ABI
     * @returns TypeScript code string
     */
    generateClass(abi: ModuleABI): string {
        const className = this.toPascalCase(abi.name) + 'Contract';
        const lines: string[] = [];

        // File header
        lines.push('/**');
        lines.push(` * Auto-generated TypeScript bindings for ${abi.address}::${abi.name}`);
        lines.push(' * Generated by @movebridge/codegen');
        lines.push(' */');
        lines.push('');
        lines.push("import type { Movement } from '@movebridge/core';");
        lines.push('');

        // Class definition
        lines.push(`export class ${className} {`);
        lines.push(`  private readonly movement: Movement;`);
        lines.push(`  private readonly address = '${abi.address}';`);
        lines.push(`  private readonly module = '${abi.name}';`);
        lines.push('');

        // Constructor
        lines.push('  /**');
        lines.push(`   * Creates a new ${className} instance`);
        lines.push('   * @param movement - Movement SDK instance');
        lines.push('   */');
        lines.push('  constructor(movement: Movement) {');
        lines.push('    this.movement = movement;');
        lines.push('  }');
        lines.push('');

        // Generate methods for each exposed function
        for (const fn of abi.exposedFunctions) {
            // Skip private functions and signer-only functions
            if (fn.visibility === 'private') continue;
            if (fn.params.length === 1 && fn.params[0] === '&signer') continue;

            const method = this.generateMethod(fn);
            lines.push(method);
            lines.push('');
        }

        lines.push('}');

        return lines.join('\n');
    }

    /**
     * Generates a method from a function ABI
     * @param fn - Function ABI
     * @returns Method code string
     */
    private generateMethod(fn: FunctionABI): string {
        const lines: string[] = [];
        const methodName = this.toCamelCase(fn.name);

        // Filter out signer params
        const params = fn.params.filter((p) => p !== '&signer' && p !== 'signer');
        const paramNames = params.map((_, i) => `arg${i}`);
        const paramTypes = params.map((p) => this.parser.parseType(p));

        // Build generic type params
        let genericParams = '';
        if (fn.genericTypeParams.length > 0) {
            const typeParams = fn.genericTypeParams.map((_, i) => `T${i} = unknown`);
            genericParams = `<${typeParams.join(', ')}>`;
        }

        // Build parameter list
        const paramList = paramNames
            .map((name, i) => `${name}: ${paramTypes[i]}`)
            .join(', ');

        // Build type arguments parameter if needed
        const hasTypeArgs = fn.genericTypeParams.length > 0;
        const typeArgsParam = hasTypeArgs ? ', typeArgs: string[]' : '';

        // Determine return type
        let returnType: string;
        if (fn.isView) {
            if (fn.return.length === 0) {
                returnType = 'void';
            } else if (fn.return.length === 1) {
                returnType = this.parser.parseType(fn.return[0] ?? 'unknown');
            } else {
                returnType = `[${fn.return.map((r) => this.parser.parseType(r ?? 'unknown')).join(', ')}]`;
            }
        } else {
            returnType = 'string'; // Transaction hash
        }

        // JSDoc
        lines.push('  /**');
        lines.push(`   * ${fn.isView ? 'View' : 'Entry'} function: ${fn.name}`);
        paramNames.forEach((name, i) => {
            lines.push(`   * @param ${name} - Parameter of type ${params[i]}`);
        });
        if (hasTypeArgs) {
            lines.push('   * @param typeArgs - Type arguments');
        }
        lines.push(`   * @returns ${fn.isView ? 'Function result' : 'Transaction hash'}`);
        lines.push('   */');

        // Method signature
        const asyncKeyword = 'async';
        lines.push(
            `  ${asyncKeyword} ${methodName}${genericParams}(${paramList}${typeArgsParam}): Promise<${returnType}> {`
        );

        // Method body
        const argsArray = paramNames.length > 0 ? `[${paramNames.join(', ')}]` : '[]';
        const typeArgsArray = hasTypeArgs ? 'typeArgs' : '[]';

        if (fn.isView) {
            lines.push(`    const contract = this.movement.contract({`);
            lines.push(`      address: this.address,`);
            lines.push(`      module: this.module,`);
            lines.push(`    });`);
            lines.push(`    return contract.view<${returnType}>('${fn.name}', ${argsArray}, ${typeArgsArray});`);
        } else {
            lines.push(`    const contract = this.movement.contract({`);
            lines.push(`      address: this.address,`);
            lines.push(`      module: this.module,`);
            lines.push(`    });`);
            lines.push(`    return contract.call('${fn.name}', ${argsArray}, ${typeArgsArray});`);
        }

        lines.push('  }');

        return lines.join('\n');
    }

    /**
     * Converts a snake_case string to PascalCase
     */
    private toPascalCase(str: string): string {
        return str
            .split('_')
            .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
            .join('');
    }

    /**
     * Converts a snake_case string to camelCase
     */
    private toCamelCase(str: string): string {
        const pascal = this.toPascalCase(str);
        return pascal.charAt(0).toLowerCase() + pascal.slice(1);
    }
}
