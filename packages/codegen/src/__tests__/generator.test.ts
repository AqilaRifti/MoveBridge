/**
 * @movebridge/codegen - Type Generator Tests
 */

import { describe, it, expect, vi, beforeEach } from 'vitest';
import { TypeGenerator } from '../generator';
import { ABIParser, type ModuleABI } from '../parser';

// Mock the ABIParser
vi.mock('../parser', () => ({
    ABIParser: vi.fn().mockImplementation(() => ({
        parseType: vi.fn((type: string) => {
            const typeMap: Record<string, string> = {
                'bool': 'boolean',
                'u8': 'number',
                'u64': 'string',
                'address': 'string',
                '&signer': 'void',
                'signer': 'void',
            };
            if (typeMap[type]) return typeMap[type];
            if (type.startsWith('vector<')) {
                const inner = type.slice(7, -1);
                return `${typeMap[inner] || 'unknown'}[]`;
            }
            if (/^T\d+$/.test(type)) return type;
            return 'unknown';
        }),
    })),
}));

describe('TypeGenerator', () => {
    let generator: TypeGenerator;
    let mockParser: ABIParser;

    beforeEach(() => {
        vi.clearAllMocks();
        mockParser = new ABIParser('testnet');
        generator = new TypeGenerator(mockParser);
    });

    describe('generateClass', () => {
        it('should generate class with correct name', () => {
            const abi: ModuleABI = {
                address: '0x1',
                name: 'coin',
                exposedFunctions: [],
            };

            const code = generator.generateClass(abi);

            expect(code).toContain('export class CoinContract');
            expect(code).toContain("private readonly address = '0x1'");
            expect(code).toContain("private readonly module = 'coin'");
        });

        it('should generate file header with module info', () => {
            const abi: ModuleABI = {
                address: '0x1',
                name: 'coin',
                exposedFunctions: [],
            };

            const code = generator.generateClass(abi);

            expect(code).toContain('Auto-generated TypeScript bindings for 0x1::coin');
            expect(code).toContain('Generated by @movebridge/codegen');
        });

        it('should import Movement from @movebridge/core', () => {
            const abi: ModuleABI = {
                address: '0x1',
                name: 'coin',
                exposedFunctions: [],
            };

            const code = generator.generateClass(abi);

            expect(code).toContain("import type { Movement } from '@movebridge/core'");
        });

        it('should generate constructor accepting Movement instance', () => {
            const abi: ModuleABI = {
                address: '0x1',
                name: 'coin',
                exposedFunctions: [],
            };

            const code = generator.generateClass(abi);

            expect(code).toContain('constructor(movement: Movement)');
            expect(code).toContain('this.movement = movement');
        });

        it('should convert snake_case module name to PascalCase', () => {
            const abi: ModuleABI = {
                address: '0x1',
                name: 'my_token_module',
                exposedFunctions: [],
            };

            const code = generator.generateClass(abi);

            expect(code).toContain('export class MyTokenModuleContract');
        });

        it('should skip private functions', () => {
            const abi: ModuleABI = {
                address: '0x1',
                name: 'test',
                exposedFunctions: [
                    {
                        name: 'private_fn',
                        visibility: 'private',
                        isEntry: false,
                        isView: false,
                        genericTypeParams: [],
                        params: [],
                        return: [],
                    },
                ],
            };

            const code = generator.generateClass(abi);

            expect(code).not.toContain('privateFn');
        });

        it('should skip signer-only functions', () => {
            const abi: ModuleABI = {
                address: '0x1',
                name: 'test',
                exposedFunctions: [
                    {
                        name: 'signer_only',
                        visibility: 'public',
                        isEntry: true,
                        isView: false,
                        genericTypeParams: [],
                        params: ['&signer'],
                        return: [],
                    },
                ],
            };

            const code = generator.generateClass(abi);

            expect(code).not.toContain('signerOnly');
        });

        it('should generate view function method', () => {
            const abi: ModuleABI = {
                address: '0x1',
                name: 'coin',
                exposedFunctions: [
                    {
                        name: 'balance',
                        visibility: 'public',
                        isEntry: false,
                        isView: true,
                        genericTypeParams: [],
                        params: ['address'],
                        return: ['u64'],
                    },
                ],
            };

            const code = generator.generateClass(abi);

            expect(code).toContain('async balance');
            expect(code).toContain('contract.view');
            expect(code).toContain("'balance'");
        });

        it('should generate entry function method', () => {
            const abi: ModuleABI = {
                address: '0x1',
                name: 'coin',
                exposedFunctions: [
                    {
                        name: 'transfer',
                        visibility: 'public',
                        isEntry: true,
                        isView: false,
                        genericTypeParams: [],
                        params: ['&signer', 'address', 'u64'],
                        return: [],
                    },
                ],
            };

            const code = generator.generateClass(abi);

            expect(code).toContain('async transfer');
            expect(code).toContain('contract.call');
            expect(code).toContain("'transfer'");
        });

        it('should filter out signer params from method signature', () => {
            const abi: ModuleABI = {
                address: '0x1',
                name: 'coin',
                exposedFunctions: [
                    {
                        name: 'transfer',
                        visibility: 'public',
                        isEntry: true,
                        isView: false,
                        genericTypeParams: [],
                        params: ['&signer', 'address', 'u64'],
                        return: [],
                    },
                ],
            };

            const code = generator.generateClass(abi);

            // Should have 2 params (address, u64) not 3
            expect(code).toContain('arg0: string, arg1: string');
            expect(code).not.toContain('arg2');
        });

        it('should handle generic type parameters', () => {
            const abi: ModuleABI = {
                address: '0x1',
                name: 'coin',
                exposedFunctions: [
                    {
                        name: 'withdraw',
                        visibility: 'public',
                        isEntry: true,
                        isView: false,
                        genericTypeParams: [{ constraints: [] }],
                        params: ['&signer', 'u64'],
                        return: [],
                    },
                ],
            };

            const code = generator.generateClass(abi);

            expect(code).toContain('<T0 = unknown>');
            expect(code).toContain('typeArgs: string[]');
        });

        it('should handle multiple generic type parameters', () => {
            const abi: ModuleABI = {
                address: '0x1',
                name: 'swap',
                exposedFunctions: [
                    {
                        name: 'swap_exact',
                        visibility: 'public',
                        isEntry: true,
                        isView: false,
                        genericTypeParams: [{ constraints: [] }, { constraints: [] }],
                        params: ['&signer', 'u64'],
                        return: [],
                    },
                ],
            };

            const code = generator.generateClass(abi);

            expect(code).toContain('<T0 = unknown, T1 = unknown>');
        });

        it('should generate JSDoc comments for methods', () => {
            const abi: ModuleABI = {
                address: '0x1',
                name: 'coin',
                exposedFunctions: [
                    {
                        name: 'balance',
                        visibility: 'public',
                        isEntry: false,
                        isView: true,
                        genericTypeParams: [],
                        params: ['address'],
                        return: ['u64'],
                    },
                ],
            };

            const code = generator.generateClass(abi);

            expect(code).toContain('* View function: balance');
            expect(code).toContain('@param arg0');
            expect(code).toContain('@returns Function result');
        });

        it('should return void for view functions with no return', () => {
            const abi: ModuleABI = {
                address: '0x1',
                name: 'test',
                exposedFunctions: [
                    {
                        name: 'check',
                        visibility: 'public',
                        isEntry: false,
                        isView: true,
                        genericTypeParams: [],
                        params: [],
                        return: [],
                    },
                ],
            };

            const code = generator.generateClass(abi);

            expect(code).toContain('Promise<void>');
        });

        it('should return tuple for view functions with multiple returns', () => {
            const abi: ModuleABI = {
                address: '0x1',
                name: 'test',
                exposedFunctions: [
                    {
                        name: 'get_pair',
                        visibility: 'public',
                        isEntry: false,
                        isView: true,
                        genericTypeParams: [],
                        params: [],
                        return: ['u64', 'u64'],
                    },
                ],
            };

            const code = generator.generateClass(abi);

            expect(code).toContain('Promise<[string, string]>');
        });

        it('should return string (tx hash) for entry functions', () => {
            const abi: ModuleABI = {
                address: '0x1',
                name: 'test',
                exposedFunctions: [
                    {
                        name: 'do_something',
                        visibility: 'public',
                        isEntry: true,
                        isView: false,
                        genericTypeParams: [],
                        params: ['&signer'],
                        return: [],
                    },
                ],
            };

            // This function only has signer param, so it will be skipped
            // Let's add another param
            const abi2: ModuleABI = {
                address: '0x1',
                name: 'test',
                exposedFunctions: [
                    {
                        name: 'do_something',
                        visibility: 'public',
                        isEntry: true,
                        isView: false,
                        genericTypeParams: [],
                        params: ['&signer', 'u64'],
                        return: [],
                    },
                ],
            };

            const code = generator.generateClass(abi2);

            expect(code).toContain('Promise<string>');
        });
    });
});
